//===--- tools/extra/clang-tidy/ClangTidyDiagnosticMapping.cpp -----------=== //
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "ClangTidyDiagnosticMapping.h"
#include "ClangTidy.h"
#include "clang/Basic/DiagnosticIDs.h"

namespace clang::tidy {

ClangTidyDiagnosticMapping::ClangTidyDiagnosticMapping(
    ClangTidyContext &Context, DiagnosticConsumer &DiagConsumer)
    : Context(Context), DiagConsumer(DiagConsumer) {

  addCustomDiagnostic(
      "clang-diagnostic-comment",
      std::make_unique<CustomDiagnostic>("Testing", "Hello world"));
  // addCustomDiagnostic("unused", "testing2");
}

void ClangTidyDiagnosticMapping::clear() { DiagConsumer.clear(); }

void ClangTidyDiagnosticMapping::BeginSourceFile(const LangOptions &LangOpts,
                                                 const Preprocessor *PP) {
  DiagConsumer.BeginSourceFile(LangOpts, PP);
}

void ClangTidyDiagnosticMapping::EndSourceFile() {
  DiagConsumer.EndSourceFile();
}

void ClangTidyDiagnosticMapping::finish() { DiagConsumer.finish(); }

bool ClangTidyDiagnosticMapping::IncludeInDiagnosticCounts() const {
  return DiagConsumer.IncludeInDiagnosticCounts();
}

void ClangTidyDiagnosticMapping::HandleDiagnostic(
    DiagnosticsEngine::Level DiagLevel, const Diagnostic &Info) {

  if (Context.DiagEngine) {
    // Temporarily switch the diagnostic client to prevent recursion and
    // avoid analyzing diagnostics generated by DiagnosticMapping itself.
    // This ensures that only diagnostics emitted from other sources
    // are analyzed and potentially remapped to a different ID.
    Context.DiagEngine->setClient(&DiagConsumer, false);

    auto CheckName = Context.getCheckName(Info.getID());
    auto it = DiagnosticMapping.find(CheckName);

    if (it != DiagnosticMapping.end()) {
      const CustomDiagnosticEntry &Entry = it->second;

      for (const auto &DiagPtr : Entry.getDiagnostics()) {
        const CustomDiagnostic &Diag = *DiagPtr;
        Context.diag(Diag.getCheckName(), Info.getLocation(),
                     Diag.getMessage());
      }
    }

    llvm::outs() << Info.getID() << " " << Context.getCheckName(Info.getID())
                 << "\n";
    Context.DiagEngine->setClient(this, false);

  } else {
    llvm::outs() << "Fail: " << Info.getID() << " " << "\n";
  }

  DiagConsumer.HandleDiagnostic(DiagLevel, Info);
  NumWarnings = DiagConsumer.getNumWarnings();
  NumErrors = DiagConsumer.getNumErrors();
}

void ClangTidyDiagnosticMapping::addCustomDiagnostic(
    StringRef CheckName, std::unique_ptr<CustomDiagnostic> Diagnostic) {

  CustomDiagnosticEntry &Entry = DiagnosticMapping[CheckName];
  Entry.addDiagnostic(std::move(Diagnostic));
}

} // namespace clang::tidy
