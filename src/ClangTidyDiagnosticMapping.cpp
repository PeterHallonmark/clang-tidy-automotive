//===--- tools/extra/clang-tidy/ClangTidyDiagnosticMapping.cpp -----------=== //
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "ClangTidyDiagnosticMapping.h"
#include "ClangTidy.h"
#include "clang/Basic/DiagnosticIDs.h"

namespace clang::tidy {

ClangTidyDiagnosticMapping::ClangTidyDiagnosticMapping(
    ClangTidyContext &Context, DiagnosticConsumer &DiagConsumer)
    : Context(Context), DiagConsumer(DiagConsumer) {

  addCustomDiagnostic("clang-diagnostic-comment", "testing");
  addCustomDiagnostic("unused", "testing2");
}

void ClangTidyDiagnosticMapping::clear() { DiagConsumer.clear(); }

void ClangTidyDiagnosticMapping::BeginSourceFile(const LangOptions &LangOpts,
                                                 const Preprocessor *PP) {
  DiagConsumer.BeginSourceFile(LangOpts, PP);
}

void ClangTidyDiagnosticMapping::EndSourceFile() {
  DiagConsumer.EndSourceFile();
}

void ClangTidyDiagnosticMapping::finish() { DiagConsumer.finish(); }

bool ClangTidyDiagnosticMapping::IncludeInDiagnosticCounts() const {
  return DiagConsumer.IncludeInDiagnosticCounts();
}

void ClangTidyDiagnosticMapping::HandleDiagnostic(
    DiagnosticsEngine::Level DiagLevel, const Diagnostic &Info) {

  if (Context.DiagEngine) {
    // Temporarily switch the diagnostic client to prevent recursion and
    // avoid analyzing diagnostics generated by DiagnosticMapping itself.
    // This ensures that only diagnostics emitted from other sources
    // are analyzed and potentially remapped to a different ID.
    Context.DiagEngine->setClient(&DiagConsumer, false);

    auto CheckName = Context.getCheckName(Info.getID());
    auto it = DiagnosticMapping.find(CheckName);

    if (it != DiagnosticMapping.end()) {
      llvm::StringRef value = it->second;
      Context.diag(value, Info.getLocation(), "testing testing");
    }

    llvm::outs() << Info.getID() << " " << Context.getCheckName(Info.getID())
                 << "\n";
    Context.DiagEngine->setClient(this, false);

  } else {
    llvm::outs() << "Fail: " << Info.getID() << " " << "\n";
  }

  DiagConsumer.HandleDiagnostic(DiagLevel, Info);
  NumWarnings = DiagConsumer.getNumWarnings();
  NumErrors = DiagConsumer.getNumErrors();
}

void ClangTidyDiagnosticMapping::addCustomDiagnostic(StringRef CheckName,
                                                     StringRef NewName) {
  // Simplified implementation to start with something.
  DiagnosticMapping[CheckName] = NewName;
}

} // namespace clang::tidy
