//===--- tools/extra/clang-tidy/ClangTidyDiagnosticMapping.cpp -----------=== //
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "ClangTidyDiagnosticMapping.h"
#include "ClangTidy.h"
#include "clang/Basic/DiagnosticIDs.h"
#include "llvm/Support/JSON.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/Error.h"

namespace clang::tidy {

namespace {

class DiagnosticMappingReader {
public:
  DiagnosticMappingReader() {}
};

}

llvm::Expected<llvm::json::Value> loadJSON(llvm::StringRef Path) {
  auto BufferOrErr = llvm::MemoryBuffer::getFile(Path);
  if (!BufferOrErr)
    return llvm::errorCodeToError(BufferOrErr.getError());

  return llvm::json::parse(BufferOrErr.get()->getBuffer());
}


ClangTidyDiagnosticMapping::ClangTidyDiagnosticMapping(
    ClangTidyContext &Context, DiagnosticConsumer &DiagConsumer)
    : Context(Context), DiagConsumer(DiagConsumer) {

  addCustomDiagnostic(
      "clang-diagnostic-comment",
      std::make_unique<ClangTidyCustomDiagnostic>("Testing", "Hello world"));
  addCustomDiagnostic(
      "clang-diagnostic-comment",
      std::make_unique<ClangTidyCustomDiagnostic>("Testing2", "Hello world2"));

  DiagnosticMappingReader Reader;

  
  auto ParsedOrErr = loadJSON("M_C_2023_mapping.json");
  if (!ParsedOrErr) {
    llvm::errs() << "Error parsing JSON: "
                 << llvm::toString(ParsedOrErr.takeError()) << "\n";
    return;
  }

  

  if (auto *Obj = ParsedOrErr->getAsObject()) {
    if (auto *Arr = Obj->getArray("diagnostic-mappings")) {
      auto Iter = Arr->begin();

      while (Iter != Arr->end()) {
        if (auto *Item = Iter->getAsObject()) {      
          llvm::outs() << Item->getString("name") << "\n";
          llvm::outs() << Item->getString("flag") << "\n";
          llvm::outs() << Item->getString("replace") << "\n";
          llvm::outs() << Item->getString("ref") << "\n";
        }
        Iter++;
      }
    }
  }
}

void ClangTidyDiagnosticMapping::clear() { DiagConsumer.clear(); }

void ClangTidyDiagnosticMapping::BeginSourceFile(const LangOptions &LangOpts,
                                                 const Preprocessor *PP) {
  DiagConsumer.BeginSourceFile(LangOpts, PP);
}

void ClangTidyDiagnosticMapping::EndSourceFile() {
  DiagConsumer.EndSourceFile();
}

void ClangTidyDiagnosticMapping::finish() { DiagConsumer.finish(); }

bool ClangTidyDiagnosticMapping::IncludeInDiagnosticCounts() const {
  return DiagConsumer.IncludeInDiagnosticCounts();
}

void ClangTidyDiagnosticMapping::HandleDiagnostic(
    DiagnosticsEngine::Level DiagLevel, const Diagnostic &Info) {

  // The mapping functionality does not work without a diagnostic engine.
  assert(Context.DiagEngine &&
         "diagnostic mapping requires a diagnostic engine to work");

  auto CheckName = Context.getCheckName(Info.getID());
  auto it = DiagnosticMapping.find(CheckName);

  if (it != DiagnosticMapping.end()) {
    const CustomDiagnosticEntry &Entry = it->second;

    // Check if the original diagnostic message should remain.
    if (Entry.keepOriginalDiagnostic()) {
      DiagConsumer.HandleDiagnostic(DiagLevel, Info);
    }

    // Temporarily switch the diagnostic client to prevent recursion and
    // avoid analyzing diagnostics generated by DiagnosticMapping itself.
    // This ensures that only diagnostics emitted from other sources
    // are analyzed and potentially remapped to a different ID.
    Context.DiagEngine->setClient(&DiagConsumer, false);

    for (const auto &DiagPtr : Entry.getDiagnostics()) {
      const ClangTidyCustomDiagnostic &Diag = *DiagPtr;
      Context.diag(Diag.getCheckName(), Info.getLocation(), Diag.getMessage());
    }

    // Restore the diagnostic client to be able to intercept all
    // diagnostics with the DiagnosticMapping class.
    Context.DiagEngine->setClient(this, false);
  } else {
    DiagConsumer.HandleDiagnostic(DiagLevel, Info);
  }

  // TODO: remove temporary printout.
  llvm::outs() << Info.getID() << " " << Context.getCheckName(Info.getID())
               << "\n";
  // Update all the diagnostic statistics from the original diagnostic consumer
  // since this class is unaware of it.
  NumWarnings = DiagConsumer.getNumWarnings();
  NumErrors = DiagConsumer.getNumErrors();
}

void ClangTidyDiagnosticMapping::addCustomDiagnostic(
    StringRef CheckName,
    std::unique_ptr<ClangTidyCustomDiagnostic> Diagnostic) {

  CustomDiagnosticEntry &Entry = DiagnosticMapping[CheckName];
  Entry.addDiagnostic(std::move(Diagnostic));
}

} // namespace clang::tidy
